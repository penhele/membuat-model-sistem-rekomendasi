# -*- coding: utf-8 -*-
"""notebook-movie-recommendation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q9tksv0b7VREay7-P6bDkZO_EXhRYnbw

# Import Library
"""

from google.colab import userdata

import ast
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from collections import Counter

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""# Memuat Dataset"""

# Ambil kredensial dari Google Colab Secrets
kaggle_username = userdata.get('kaggle_username')  # Nama pengguna
kaggle_key = userdata.get('kaggle_key')     # Kunci API

# Set variabel lingkungan untuk Kaggle
os.environ['KAGGLE_USERNAME'] = kaggle_username
os.environ['KAGGLE_KEY'] = kaggle_key

!kaggle datasets download -d CooperUnion/anime-recommendations-database

!unzip anime-recommendations-database.zip

df_anime = pd.read_csv('anime.csv')

df_rating = pd.read_csv('rating.csv')

"""# Exploratory Data Analysis (EDA)

## Anime Variabel

Menampilkan Isi dan Struktur Dataset Anime
"""

df_anime.head()

df_anime.info()

all_genres = df_anime['genre'].dropna().str.split(', ')
flat_genres = [genre for sublist in all_genres for genre in sublist]
genre_counts = Counter(flat_genres)
top5_genres = genre_counts.most_common(5)

df_top_genres = pd.DataFrame(top5_genres, columns=['Genre', 'Count'])

plt.figure(figsize=(8,5))
sns.barplot(data=df_top_genres, x='Genre', y='Count', palette='viridis')
plt.title('Top 5 Genre Paling Banyak di Dataset Anime')
plt.ylabel('Jumlah Anime')
plt.xlabel('Genre')
plt.show()

"""Insight : Dari output ini, kita dapat melihat seberapa lengkap data dan menilai kualitas dataset anime untuk analisis lebih lanjut seperti pembuatan sistem rekomendasi anime. Kemudian pada visualisasi terdapat genre terbanyak pada dataset ini. Genre Comedy menjadi genre paling banyak.

## Rating Variabel

Menampilkan Isi dan Struktur Dataset Rating
"""

df_rating.head()

df_rating.info()

df_rating = df_rating[df_rating.user_id <= 10000]

rating_counts = df_rating['anime_id'].value_counts().head(5)

top5_rated_anime = pd.DataFrame({
    'anime_id': rating_counts.index,
    'rating_count': rating_counts.values
}).merge(df_anime[['anime_id', 'name']], on='anime_id')

plt.figure(figsize=(10,6))
sns.barplot(data=top5_rated_anime, x='rating_count', y='name', hue='name', dodge=False, legend=False)
plt.title('Top 5 Anime dengan Jumlah Rating Terbanyak')
plt.xlabel('Jumlah Rating')
plt.ylabel('Nama Anime')
plt.show()

"""Insight : Dari output ini, kita dapat melihat seberapa lengkap data dan menilai kualitas dataset rating untuk analisis lebih lanjut seperti pembuatan sistem rekomendasi anime. Kode `df_rating = df_rating[df_rating.user_id <= 10000]` digunakan untuk mengambil user_id di bawah 10000. Hal ini agar pada proses rekomendasi tidak terlalu banyak mengambil data. Lalu pada visualisasi Anime `Death Note` menjadi rating terbanyak.

# Data Preparation

## Mengatasi Rating Tidak Valid

Membersihkan nilai rating tidak valid pada dataset rating
"""

df_rating['rating'].unique()

df_rating['rating'] = df_rating['rating'].replace(-1, pd.NA)

"""Insight :
- `df_rating['rating'].unique()` digunakan untuk mengecek semua nilai unik yang terdapat dalam kolom rating. Ini berguna untuk menemukan adanya nilai tidak valid atau anomali, seperti -1 yang biasanya menandakan bahwa user belum memberi rating sebenarnya (misalnya hanya menonton tapi tidak menilai).

- `df_rating['rating'] = df_rating['rating'].replace(-1, pd.NA)` mengganti semua nilai -1 dengan pd.NA (missing value dalam Pandas). Ini penting agar model rekomendasi tidak menganggap -1 sebagai rating numerik yang valid. Nilai ini nantinya bisa diabaikan saat melakukan perhitungan seperti similarity atau rekomendasi.

## Mengatasi Missing Value

Membersihkan nilai kosong pada dataset anime dan rating
"""

df_anime.isnull().sum()

df_anime.dropna(inplace=True)

df_rating.isnull().sum()

df_rating.dropna(inplace=True)

"""Insight :
- Pada dataset anime, terdapat nilai null pada kolom genre, type, dan rating. Karena tidak jumlah null masih tergolong sedikkit, jadi diputuskan untuk menghapus nilai null tersebut.
- Pada dataset rating, terdapat banyak sekali nilai null pada kolom rating. Hal ini disebabkan pada kode sebelumnya bahwa mengganti nilai anomali (-1) menjadi NaN. Karena -1 adalah pengguna yang menonton tetapi tidak menilai, maka akan dihapus. Jika dijadikan 0, maka akan merusak anime tersebut karena jika 0 akan terdeteksi film tersebut jelek.

## Mengatasi Duplicated Value

Membersihkan nilai duplikat pada dataset anime dan rating
"""

df_anime.duplicated().sum()

df_rating.duplicated().sum()

"""Insight : Kode tersebut digunakan untuk mendeteksi apakah ada data duplikat pada kedua dataset, yaitu `df_anime` dan `df_rating`. Fungsi `df_anime.duplicated().sum()` dan `df_rating.duplicated().sum()` menghitung jumlah baris yang terdeteksi sebagai duplikat dalam masing-masing dataframe. Hasil dari kedua perintah tersebut adalah `np.int64(0)`, yang berarti **tidak ada baris duplikat** yang ditemukan dalam kedua dataset. Ini menunjukkan bahwa data yang digunakan sudah bersih dari duplikasi, sehingga tidak perlu dilakukan penghapusan duplikat. Hal ini penting karena data duplikat dapat menyebabkan bias dalam perhitungan rekomendasi, terutama jika rating yang sama dihitung lebih dari sekali.

# Model Development

## Content Based Filtering

### Count Vectorizer

Meng-ektraksi fitur genre menggunakan CountVectorizer
"""

vectorizer = CountVectorizer(tokenizer=lambda x: x.split(', '))
genre_matrix = vectorizer.fit_transform(df_anime['genre']).toarray()

"""Insight : Kode tersebut digunakan untuk membangun matriks kesamaan (similarity matrix) antar anime berdasarkan genre yang mereka miliki. Pertama, `CountVectorizer` digunakan dengan `tokenizer=lambda x: x.split(', ')`, yang berarti genre pada setiap anime akan dipisahkan berdasarkan koma. Misalnya, genre "Action, Adventure, Comedy" akan diubah menjadi tiga token: "Action", "Adventure", dan "Comedy". Hasil transformasi ini adalah sebuah `genre_matrix` berupa array numerik biner yang menunjukkan keberadaan suatu genre pada setiap anime.

### Cosine Similarity

Menghitung kemiripan antara anime berdasarkan genre dengan Cosine Similarity
"""

anime_similarity = cosine_similarity(genre_matrix)
anime_similarity

"""Insight : `cosine_similarity(genre_matrix)` menghitung kemiripan kosinus antar anime berdasarkan vektor genre mereka. Nilai dalam `anime_similarity` akan berada dalam rentang 0 hingga 1, di mana nilai yang lebih tinggi menunjukkan bahwa dua anime memiliki genre yang lebih mirip. Matriks ini nantinya dapat digunakan untuk sistem content-based filtering, yaitu memberikan rekomendasi anime yang mirip genre-nya dengan anime yang pernah disukai user. Proses ini sangat penting karena memungkinkan pemberian rekomendasi meskipun user belum banyak memberikan rating, cukup berdasarkan kesamaan konten.

### Mendapatkan Rekomendasi

Rekomendasi anime berdasarkan genre yang mirip
"""

def recommend(anime_title):
    if anime_title not in df_anime['name'].values:
        print("Anime tidak ditemukan!")
        return

    index = df_anime[df_anime['name'] == anime_title].index[0]
    distances = sorted(list(enumerate(anime_similarity[index])), reverse=True, key=lambda x: x[1])

    print(f"Rekomendasi anime mirip dengan '{anime_title}':")
    for i in distances[1:6]:
        title = df_anime.iloc[i[0]]['name']
        genre = df_anime.iloc[i[0]]['genre']
        print(f"- {title} â€” Genre: {genre}")

recommend('Kokoro ga Sakebitagatterunda.')

"""Insight : Fungsi `recommend()` memberikan 5 rekomendasi anime yang memiliki genre paling mirip dengan judul yang diberikan, menggunakan cosine similarity dari genre. Ini merupakan implementasi content-based filtering yang sederhana dan efektif.

## Collaborative Filtering

### User-Based

Rekomendasi anime berdasarkan kesamaan antar pengguna
"""

user_item_matrix = df_rating.pivot(index='user_id', columns='anime_id', values='rating')

user_similarity = cosine_similarity(user_item_matrix.fillna(0))

def user_based_recommendations(user_id, user_item_matrix, user_similarity, n=5):
    user_scores = user_similarity[user_id - 1]

    similar_users = sorted(enumerate(user_scores), key=lambda x: x[1], reverse=True)

    recommended_anime = []

    for user, score in similar_users[1:]:
        rated_anime = user_item_matrix.loc[user_item_matrix.index[user - 1]]
        positively_rated_anime = rated_anime[rated_anime >= 6].index

        target_user_rated_anime = user_item_matrix.loc[user_id].dropna().index
        recommended_anime.extend(set(positively_rated_anime) - set(target_user_rated_anime))

        if len(recommended_anime) >= n:
            break

    return recommended_anime[:n]

"""Insight : Fungsi `user_based_recommendations()` memberikan rekomendasi anime untuk pengguna tertentu berdasarkan kesamaan rating dengan pengguna lain. Sistem ini membandingkan pola rating antar pengguna menggunakan cosine similarity, lalu merekomendasikan anime yang disukai oleh pengguna serupa namun belum ditonton oleh target user. Pendekatan ini cocok saat banyak pengguna memberikan rating pada berbagai anime.

### Item-Based
"""

item_similarity = cosine_similarity(user_item_matrix.fillna(0).T)

anime_id_to_idx = {anime_id: idx for idx, anime_id in enumerate(user_item_matrix.columns)}
idx_to_anime_id = {idx: anime_id for anime_id, idx in anime_id_to_idx.items()}

"""Rekomendasi anime berdasarkan kesamaan antar item"""

def item_based_recommendations(user_id, user_item_matrix, item_similarity, anime_id_to_idx, idx_to_anime_id, n=5):
    positively_rated_anime = user_item_matrix.loc[user_id][user_item_matrix.loc[user_id] >= 6].index

    recommended_anime = set()
    user_rated_anime = set(user_item_matrix.loc[user_id].dropna().index)

    for anime_id in positively_rated_anime:
        if anime_id not in anime_id_to_idx:
            continue

        anime_idx = anime_id_to_idx[anime_id]
        similar_anime_scores = item_similarity[anime_idx]

        similar_anime_sorted = sorted(enumerate(similar_anime_scores), key=lambda x: x[1], reverse=True)

        for idx, score in similar_anime_sorted[1:]:
            candidate_anime_id = idx_to_anime_id[idx]
            if candidate_anime_id not in user_rated_anime:
                recommended_anime.add(candidate_anime_id)
            if len(recommended_anime) >= n:
                break
        if len(recommended_anime) >= n:
            break

    return list(recommended_anime)[:n]

"""Insight : Fungsi `item_based_recommendations()` menyarankan anime berdasarkan kemiripan antar anime yang disukai pengguna. Dengan menghitung cosine similarity antar kolom anime (item), sistem ini merekomendasikan anime yang mirip dengan yang sudah diberi rating positif oleh pengguna, namun belum ditonton. Pendekatan ini efektif saat data pengguna sedikit, tapi data item melimpah.

### Mendapatkan Rekomendasi

Perbandingan rekomendasi anime:  User-Based vs Item-Based
"""

user_id = 15

user_recommendations = user_based_recommendations(user_id, user_item_matrix, user_similarity, n=5)

item_recommendations = item_based_recommendations(user_id, user_item_matrix, item_similarity, anime_id_to_idx, idx_to_anime_id, n=5)

print(f"User-Based Recommendations for User {user_id}:")
for anime_id in user_recommendations:
    anime_name = df_anime.loc[df_anime['anime_id'] == anime_id, 'name'].values[0]
    print(f"- {anime_name}")

print(f"\nItem-Based Recommendations for User {user_id}:")
for anime_id in item_recommendations:
    anime_name = df_anime.loc[df_anime['anime_id'] == anime_id, 'name'].values[0]
    print(f"- {anime_name}")

"""Insight : Kode ini melakukan uji coba rekomendasi anime untuk pengguna tertentu (user\_id = 15) menggunakan dua metode collaborative filtering: user-based dan item-based. Hasilnya menampilkan daftar anime yang direkomendasikan berdasarkan kemiripan antar pengguna dan kemiripan antar anime. Dengan cara ini, kita dapat membandingkan efektivitas kedua pendekatan dalam memberikan rekomendasi yang relevan bagi pengguna.

"""